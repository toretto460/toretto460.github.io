<!doctype html><html lang=en dir=auto>
<head><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Deliver notifications in the user browser | Simone's blog</title>
<meta name=keywords content="redis,golang,sse">
<meta name=description content="Delivering real-time notifications in the user browser makes your application way more engaging and let the user quickly react to the events happening in the product.">
<meta name=author content>
<link rel=canonical href=https://toretto460.github.io/posts/sse/>
<link crossorigin=anonymous href=/assets/css/stylesheet.min.5e2b4101351c21e906f398ae96901791830f58d430f96f2659dab7eaef7b3cb7.css integrity="sha256-XitBATUcIekG85iulpAXkYMPWNQw+W8mWdq36u97PLc=" rel="preload stylesheet" as=style>
<script defer crossorigin=anonymous src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://toretto460.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://toretto460.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://toretto460.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://toretto460.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://toretto460.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.89.2">
<noscript>
<style>#theme-toggle,.top-link{display:none}</style>
</noscript><meta property="og:title" content="Deliver notifications in the user browser">
<meta property="og:description" content="Delivering real-time notifications in the user browser makes your application way more engaging and let the user quickly react to the events happening in the product.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://toretto460.github.io/posts/sse/">
<meta property="og:image" content="https://toretto460.github.io/posts/sse/imgs/adam-solomon-WHUDOzd5IYU-unsplash.jpg"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-11-12T15:25:11+02:00">
<meta property="article:modified_time" content="2021-11-12T15:25:11+02:00">
<meta name=twitter:card content="summary_large_image">
<meta name=twitter:image content="https://toretto460.github.io/posts/sse/imgs/adam-solomon-WHUDOzd5IYU-unsplash.jpg">
<meta name=twitter:title content="Deliver notifications in the user browser">
<meta name=twitter:description content="Delivering real-time notifications in the user browser makes your application way more engaging and let the user quickly react to the events happening in the product.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://toretto460.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Deliver notifications in the user browser","item":"https://toretto460.github.io/posts/sse/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Deliver notifications in the user browser","name":"Deliver notifications in the user browser","description":"Delivering real-time notifications in the user browser makes your application way more engaging and let the user quickly react to the events happening in the product.\n","keywords":["redis","golang","sse"],"articleBody":"Delivering real-time notifications in the user browser makes your application way more engaging and let the user quickly react to the events happening in the product.\n This story starts in a meeting with your team\nYou currently work for a successful e-commerce company and youâ€™re in the middle of a grooming meeting when the product owner asks you to implement the invoice PDF generation\nYou know that invoice rendering is a very long-running job, it involves several API calls to fetch all the required data.\nThe invoice generation is something like:\ntype Invoice struct { model.User model.Order model.Payment } g, ctx := errgroup.WithContext(ctx) invoice := Invoice{} g.Go(func() error { user, err := userService.Get(\"user-id\") if err == nil { invoice.User = user } return err }) g.Go(func() error { order, err := orderService.Get(\"order-id\") if err == nil { invoice.Order = order } return err }) g.Go(func() error { payment, err := paymentService.Get(\"payment-id\") if err == nil { invoice.Payment = payment } return err }) if err := g.Wait(); err != nil { return nil, err } pdf, err := pdfInvoiceRendered.Render(invoice) if err != nil { return nil, err } return pdf, nil To generate an invoice the invoice service needs to do several API calls to the external services that own the Payment, User, Order and so onâ€¦ After that you can render the PDF using the engine of your choice; You know, all that process may take lots of time to complete the job.\nSo after a brainstorming, your team decides that itâ€™s the right time to implement something to send a notification to the user. ðŸ¥³\nIf you want to jump straight to the solution go to Notify.\nSending notifications to the browser There are several ways to implement a notification system for a web application. The easy way is to go through a polling strategy. Polling is not beautiful nor efficient because you need to get if there are new notifications at regular intervals and even worse if you have a lot of users you flood your server with huge traffic. Despite of all the cons, a polling strategy can be good for small products with relatively low traffic.\nPolling\n itâ€™s easy to implement do not require a persistent connection  A more sophisticated solution If youâ€™re still reading this post maybe youâ€™re interested in a more sophisticated solution than the polling one. So weâ€™ll go deeper into the rabbit hole.\nPersistent connection One of the most significant features that makes a polling implementation simple is that it do not rely on a persistent connection between the client and the server. Basically, you just need to implement a GET /notifications API and let the client call it to fetch new notifications. The state is preserved in the server where weâ€™ve hundreds of possibilities to store the notifcations; we can use a database, a cache, the filesystem, or whatever system we want.\nOn the other hand, if we donâ€™t want to flood the server with hundreds of requests to ask for notifications we need to set up a stable communication channel between the client and the server. Talking about HTTP this channel could be a persistent connection to be used to send messages to the client.\nâžœ ~ curl -v --keepalive http://localhost:3000/open?channel=test * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 3000 (#0)  GET /open?channel=test HTTP/1.1  Host: localhost:3000  User-Agent: curl/7.64.1  Accept: */*  200 OK 12 Nov 2021 15:52:22 GMT The HTTP / 1.1 version of the protocol supports the persistent connections, basically every connection is treated as persistent unless the client (or the server) sends a Connection: close header. This can be a very useful approach to keep the number of newly opened connection under control, even more so we have thousands of clients that need to receive notifications and constantly ping the server to ask for them.\nServer Sent Events - SSE Beside the classic HTTP request  response flow that allows the client to send a request to the server we also have the server sent events in our swiss army knife. Server sent events allows the server to push new data to the browser as long as they are ready.\nImplementing in golang Thanks to the powerful stdlib itâ€™s very easy to implement SSE in golang, you can write data over the response writer and flush it to send them to the client.\nfunc(w http.ResponseWriter, r *http.Request) { w.Header().Set(\"Access-Control-Allow-Origin\", \"*\") w.Header().Set(\"Access-Control-Allow-Headers\", \"Content-Type\") w.Header().Set(\"Content-Type\", \"text/event-stream\") w.Header().Set(\"Cache-Control\", \"no-cache\") w.Header().Set(\"Connection\", \"keep-alive\") if f, ok := w.(http.Flusher); ok { f.Flush() } go func() { for { time.Sleep(time.Second) fmt.Fprint(w, \"event: test\\n\") fmt.Fprint(w, \"data: {\\\"data\\\": 1}\\n\\n\") // Flush the write to actually send data to the client \tif f, ok := w.(http.Flusher); ok { f.Flush() } } }() r.Context().Done() } But in a real-world scenario that snippet could be not enough, you may need a more sophisticated solution for a cloud-native app that requires:\n horizontal scaling through containers release new versions with a blue/geen deployment  Notify Notify is a golang library that condensates all these concepts, it allows to send server events to the browser with ease. https://github.com/toretto460/notify is easy to use; it supports Redis as a backend to publish and subscribe to events.\nhttps://github.com/toretto460/notify\npackage main import ( \"context\" \"log\" \"net/http\" \"time\" \"github.com/go-redis/redis/v8\" \"github.com/toretto460/notify\" \"github.com/toretto460/notify/model\" ) var redisCli *redis.Client func init() { redisCli = redis.NewClient(\u0026redis.Options{ Addr: \"localhost:6379\", }) } func main() { // Get the channel factory \tchFactory := notify.Redis(redisCli) // Register the default handler \thttp.Handle(\"/listen\", notify.DefaultHandler(chFactory)) // Send some messages  go func() { channel, _ := chFactory.Get(\"test-channel-id\") channel.Send( context.Background(), model.NewMessage(\"test-message\", []byte(`{\"hello\": \"world\"}`)), ) time.Sleep(time.Second * 10) }() log.Print(\"Starting web server at :3000\") if err := http.ListenAndServe(\":3000\", nil); err != nil { log.Fatal(err) } } And then you can listen for messages in the browser\nconst channel = \"test-channel-id\" const source = new EventSource(\"http://localhost:3000/listen?channel=\" + channel) source.addEventListener('test-message', (event) = { console.log(event) // = {\"hello\": \"world\"} }) Disclaimer\nAs of today 11/11/2021 the notify library is still not used in production. Fill a PR or open a discussion here https://github.com/toretto460/notify/issues for any issue.\nCover photo by Adam Solomon on Unsplash\n","wordCount":"1032","inLanguage":"en","image":"https://toretto460.github.io/posts/sse/imgs/adam-solomon-WHUDOzd5IYU-unsplash.jpg","datePublished":"2021-11-12T15:25:11+02:00","dateModified":"2021-11-12T15:25:11+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://toretto460.github.io/posts/sse/"},"publisher":{"@type":"Organization","name":"Simone's blog","logo":{"@type":"ImageObject","url":"https://toretto460.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://toretto460.github.io/ accesskey=h title="Simone's blog (Alt + H)">Simone's blog</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu>
</ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Deliver notifications in the user browser
</h1>
<div class=post-meta>November 12, 2021
</div>
</header>
<figure class=entry-cover><img loading=lazy src=https://toretto460.github.io/imgs/adam-solomon-WHUDOzd5IYU-unsplash.jpg alt>
</figure>
<div class=post-content><p>Delivering real-time notifications in the user browser makes your application way more engaging and let the user quickly react to the events happening in the product.</p>
<hr>
<p><strong>This story starts in a meeting with your team</strong></p>
<p>You currently work for a successful e-commerce company and youâ€™re in the middle of a grooming meeting when the product owner asks you to implement the invoice PDF generation</p>
<p>You know that invoice rendering is a very long-running job, it involves several API calls to fetch all the required data.</p>
<p>The invoice generation is something like:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Invoice</span> <span style=color:#66d9ef>struct</span> {
    <span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>User</span>
    <span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Order</span>
    <span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>Payment</span>
}

<span style=color:#a6e22e>g</span>, <span style=color:#a6e22e>ctx</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>errgroup</span>.<span style=color:#a6e22e>WithContext</span>(<span style=color:#a6e22e>ctx</span>)
<span style=color:#a6e22e>invoice</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>Invoice</span>{}

<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> {
    <span style=color:#a6e22e>user</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>userService</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;user-id&#34;</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>invoice</span>.<span style=color:#a6e22e>User</span> = <span style=color:#a6e22e>user</span> 
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
})

<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> {
    <span style=color:#a6e22e>order</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>orderService</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;order-id&#34;</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>invoice</span>.<span style=color:#a6e22e>Order</span> = <span style=color:#a6e22e>order</span>
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
})

<span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Go</span>(<span style=color:#66d9ef>func</span>() <span style=color:#66d9ef>error</span> {
    <span style=color:#a6e22e>payment</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>paymentService</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;payment-id&#34;</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span> {
        <span style=color:#a6e22e>invoice</span>.<span style=color:#a6e22e>Payment</span> = <span style=color:#a6e22e>payment</span>
    }
    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
})

<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>g</span>.<span style=color:#a6e22e>Wait</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
}

<span style=color:#a6e22e>pdf</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>pdfInvoiceRendered</span>.<span style=color:#a6e22e>Render</span>(<span style=color:#a6e22e>invoice</span>)

<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>err</span>
}

<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>pdf</span>, <span style=color:#66d9ef>nil</span>
</code></pre></div><p>To generate an invoice the invoice service needs to do several API calls to the external services that own the Payment, User, Order and so on&mldr; After that you can render the PDF using the engine of your choice; You know, all that process may take lots of time to complete the job.</p>
<p>So after a brainstorming, your team decides that it&rsquo;s the right time to implement something to send a notification to the user. ðŸ¥³</p>
<p>If you want to jump straight to the solution go to <a href=https://toretto460.github.io/posts/sse/#notify>Notify</a>.</p>
<h3 id=sending-notifications-to-the-browser>Sending notifications to the browser<a hidden class=anchor aria-hidden=true href=#sending-notifications-to-the-browser>#</a></h3>
<p>There are several ways to implement a notification system for a web application. The easy way is to go through a <a href=https://en.m.wikipedia.org/wiki/Polling_(computer_science)>polling</a> strategy.
Polling is not beautiful nor efficient because you need to get if there are new notifications at regular intervals and even worse if you have a lot of users you flood your server with huge traffic.
Despite of all the cons, a polling strategy can be good for small products with relatively low traffic.</p>
<p><strong>Polling</strong></p>
<ul>
<li>it&rsquo;s easy to implement</li>
<li>do not require a persistent connection</li>
</ul>
<h2 id=a-more-sophisticated-solution>A more sophisticated solution<a hidden class=anchor aria-hidden=true href=#a-more-sophisticated-solution>#</a></h2>
<p>If youâ€™re still reading this post maybe youâ€™re interested in a more sophisticated solution than the polling one. So we&rsquo;ll go deeper into the rabbit hole.</p>
<h3 id=persistent-connection>Persistent connection<a hidden class=anchor aria-hidden=true href=#persistent-connection>#</a></h3>
<p>One of the most significant features that makes a polling implementation simple is that it do not rely on a persistent connection between the client and the server.
Basically, you just need to implement a <code>GET /notifications</code> API and let the client call it to fetch new notifications.
The state is preserved in the server where we&rsquo;ve hundreds of possibilities to store the notifcations; we can use a database, a cache, the filesystem, or whatever system we want.</p>
<p>On the other hand, if we don&rsquo;t want to flood the server with hundreds of requests to ask for notifications we need to set up a stable communication channel between the client and the server. Talking about HTTP this channel could be a persistent connection to be used to send messages to the client.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>âžœ  ~ curl -v --keepalive http://localhost:3000/open?channel<span style=color:#f92672>=</span>test
*   Trying ::1...
* TCP_NODELAY set
* Connected to localhost <span style=color:#f92672>(</span>::1<span style=color:#f92672>)</span> port <span style=color:#ae81ff>3000</span> <span style=color:#f92672>(</span><span style=color:#75715e>#0)</span>
&gt; GET /open?channel<span style=color:#f92672>=</span>test HTTP/1.1
&gt; Host: localhost:3000
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 <span style=color:#ae81ff>200</span> OK
&lt; Cache-Control: no-cache
&lt; Connection: keep-alive
&lt; Content-Type: text/event-stream
&lt; Date: Fri, <span style=color:#ae81ff>12</span> Nov <span style=color:#ae81ff>2021</span> 15:52:22 GMT
&lt; Transfer-Encoding: chunked
</code></pre></div><p>The <a href=https://en.wikipedia.org/wiki/HTTP_persistent_connection>HTTP / 1.1</a> version of the protocol supports the persistent connections, basically every connection is treated as persistent unless the client (or the server) sends a <code>Connection: close</code> header.
This can be a very useful approach to keep the number of newly opened connection under control, even more so we have thousands of clients that need to receive notifications and constantly ping the server to ask for them.</p>
<h3 id=server-sent-events---sse>Server Sent Events - SSE<a hidden class=anchor aria-hidden=true href=#server-sent-events---sse>#</a></h3>
<p>Beside the classic HTTP request &lt;-> response flow that allows the client to send a request to the server we also have the server sent events in our swiss army knife.
<strong>Server sent events</strong> allows the server to push new data to the browser as long as they are ready.</p>
<h3 id=implementing-in-golang>Implementing in golang<a hidden class=anchor aria-hidden=true href=#implementing-in-golang>#</a></h3>
<p>Thanks to the powerful stdlib it&rsquo;s very easy to implement SSE in golang, you can write data over the response writer and flush it to send them to the client.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>r</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Access-Control-Allow-Origin&#34;</span>, <span style=color:#e6db74>&#34;*&#34;</span>)
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Access-Control-Allow-Headers&#34;</span>, <span style=color:#e6db74>&#34;Content-Type&#34;</span>)
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Content-Type&#34;</span>, <span style=color:#e6db74>&#34;text/event-stream&#34;</span>)
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Cache-Control&#34;</span>, <span style=color:#e6db74>&#34;no-cache&#34;</span>)
	<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Connection&#34;</span>, <span style=color:#e6db74>&#34;keep-alive&#34;</span>)
    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>w</span>.(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Flusher</span>); <span style=color:#a6e22e>ok</span> {
        <span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Flush</span>()
    }

	<span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#66d9ef>for</span> {
			<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)

			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;event: test\n&#34;</span>)
			<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Fprint</span>(<span style=color:#a6e22e>w</span>, <span style=color:#e6db74>&#34;data: {\&#34;data\&#34;: 1}\n\n&#34;</span>)

			<span style=color:#75715e>// Flush the write to actually send data to the client
</span><span style=color:#75715e></span>			<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>f</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>w</span>.(<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Flusher</span>); <span style=color:#a6e22e>ok</span> {
				<span style=color:#a6e22e>f</span>.<span style=color:#a6e22e>Flush</span>()
			}
		}
	}()

	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>r</span>.<span style=color:#a6e22e>Context</span>().<span style=color:#a6e22e>Done</span>()
}
</code></pre></div><p>But in a real-world scenario that snippet could be not enough, you may need a more sophisticated solution for a cloud-native app that requires:</p>
<ul>
<li>horizontal scaling through containers</li>
<li>release new versions with a <a href=https://en.wikipedia.org/wiki/Blue-green_deployment>blue/geen deployment</a></li>
</ul>
<h3 id=notify>Notify<a hidden class=anchor aria-hidden=true href=#notify>#</a></h3>
<p>Notify is a golang library that condensates all these concepts, it allows to <strong>send server events</strong> to the browser with ease.
<a href=https://github.com/toretto460/notify>https://github.com/toretto460/notify</a> is easy to use; it supports Redis as a backend to publish and subscribe to events.</p>
<p><a href=https://github.com/toretto460/notify/blob/main/example/web/main.go>https://github.com/toretto460/notify</a></p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;context&#34;</span>
	<span style=color:#e6db74>&#34;log&#34;</span>
	<span style=color:#e6db74>&#34;net/http&#34;</span>
	<span style=color:#e6db74>&#34;time&#34;</span>

	<span style=color:#e6db74>&#34;github.com/go-redis/redis/v8&#34;</span>

	<span style=color:#e6db74>&#34;github.com/toretto460/notify&#34;</span>
    <span style=color:#e6db74>&#34;github.com/toretto460/notify/model&#34;</span>
)

<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>redisCli</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>Client</span>

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>init</span>() {
	<span style=color:#a6e22e>redisCli</span> = <span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>NewClient</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>redis</span>.<span style=color:#a6e22e>Options</span>{
		<span style=color:#a6e22e>Addr</span>: <span style=color:#e6db74>&#34;localhost:6379&#34;</span>,
	})
}

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {  
  <span style=color:#75715e>// Get the channel factory
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>chFactory</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>notify</span>.<span style=color:#a6e22e>Redis</span>(<span style=color:#a6e22e>redisCli</span>)
  
  <span style=color:#75715e>// Register the default handler
</span><span style=color:#75715e></span>	<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Handle</span>(<span style=color:#e6db74>&#34;/listen&#34;</span>, <span style=color:#a6e22e>notify</span>.<span style=color:#a6e22e>DefaultHandler</span>(<span style=color:#a6e22e>chFactory</span>))
  
 
  <span style=color:#75715e>// Send some messages
</span><span style=color:#75715e></span>  <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
		<span style=color:#a6e22e>channel</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>chFactory</span>.<span style=color:#a6e22e>Get</span>(<span style=color:#e6db74>&#34;test-channel-id&#34;</span>)
		<span style=color:#a6e22e>channel</span>.<span style=color:#a6e22e>Send</span>(
			<span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>Background</span>(),
			<span style=color:#a6e22e>model</span>.<span style=color:#a6e22e>NewMessage</span>(<span style=color:#e6db74>&#34;test-message&#34;</span>, []byte(<span style=color:#e6db74>`{&#34;hello&#34;: &#34;world&#34;}`</span>)),
		)
		<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>10</span>)
	}()
  
	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Print</span>(<span style=color:#e6db74>&#34;Starting web server at :3000&#34;</span>)

	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ListenAndServe</span>(<span style=color:#e6db74>&#34;:3000&#34;</span>, <span style=color:#66d9ef>nil</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
	}
}
</code></pre></div><p>And then you can listen for messages in the browser</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>channel</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;test-channel-id&#34;</span>
<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>source</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>EventSource</span>(<span style=color:#e6db74>&#34;http://localhost:3000/listen?channel=&#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>channel</span>)

<span style=color:#a6e22e>source</span>.<span style=color:#a6e22e>addEventListener</span>(<span style=color:#e6db74>&#39;test-message&#39;</span>, (<span style=color:#a6e22e>event</span>) =&gt; {
	<span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#a6e22e>event</span>) <span style=color:#75715e>// =&gt; {&#34;hello&#34;: &#34;world&#34;}
</span><span style=color:#75715e></span>})
</code></pre></div><p>Disclaimer</p>
<p>As of today 11/11/2021 the notify library is still not used in production. Fill a PR or open a discussion here <a href=https://github.com/toretto460/notify/issues>https://github.com/toretto460/notify/issues</a> for any issue.</p>
<div style=font-size:13px> <p>Cover photo by <a href="https://unsplash.com/@solomac?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Adam Solomon</a> on <a href="https://unsplash.com/s/photos/notification?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Unsplash</a></p>
</div>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://toretto460.github.io/tags/redis/>redis</a></li>
<li><a href=https://toretto460.github.io/tags/golang/>golang</a></li>
<li><a href=https://toretto460.github.io/tags/sse/>sse</a></li>
</ul>
</footer>
</article>
</main>
<footer class=footer>
<span>&copy; 2021 <a href=https://toretto460.github.io/>Simone's blog</a></span>
<span>
Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a>
</span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>